<!DOCTYPE html>
<html>

  <head>
    <title>CMPS161 Assignment 1</title>

    <!-- Andrew Pang 1559331 */ -->
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">

    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
    </style>

  </head>

  <body>
    <div id="map"></div>
    <script>
      var map;
      var request;
      var grid = new Array();
      var openWeatherMapKey = "e2cc8c04d4f4eb4e92d940af42c9e6b6";
      var NUMOFSTATIONS = 0;
      var dataset_stations = [];
      var dataset_interpolatedWinds = [];
      var geoJSON = 
      {
        type: "FeatureCollection",
        features: []
      };

      function toRadians (angle) {
        return angle * (Math.PI / 180);
      }

      function drawStations() {
        // Draw Stations
        if(dataset_stations.length == 0)
        {
          console.log("Dataset Station Empty!")
        }
        for(var i = 0; i < dataset_stations.length; i++)
        {
          var lat = dataset_stations[i].coord.Lat;
          var lng = dataset_stations[i].coord.Lon;
          var station_coord = new google.maps.LatLng(lat, lng);

          new google.maps.Marker({position: station_coord, map: map});
        }
      }

      function findWindEndPoint(sourcePoint, directionInDegrees, mag) {
        // Source Point ===> Interpolated Point
        // Input: LatLng() 
        // Output: LatLng()

        //var stationInJSON = sourcePoint;
        //var stationWindDeg = stationInJSON.wind.deg; // North == 0; East == 90;
        //var stationWindSpeed = stationInJSON.wind.speed;

        // Lat should be X
        // Lng should be Y

        var dx = mag*Math.cos(toRadians(directionInDegrees));
        var dy = mag*Math.sin(toRadians(directionInDegrees));

        // Apply damping so wind arrows aren't so long
        //dy *= 0.3;
        //dx *= 0.3;

        //var tail = new google.maps.LatLng(dataset_stations[i].coord.Lat, dataset_stations[i].coord.Lon);

        var newLat = (sourcePoint.lat() - dx);
        var newLng = (sourcePoint.lng() - dy);

        var head = new google.maps.LatLng(newLat, newLng);

        return head;

      }

      function drawArrowTailToHead(tail, head) {
        // Define a symbol using a predefined path (an arrow)
        var lineSymbol = {
          path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
        };

        var wind_vector = new google.maps.Polyline({
          path: [tail, head],
          icons: [{
            icon: lineSymbol,
            offset: '100%'
          }],
          strokeWeight: "2",
          strokeOpacity: "0.8",
          map: map
        });

      }

      function drawStationWinds() {
        // Draw wind vector for each station
        // Check if dataset of stations is empty
        if(dataset_stations.length == 0)
        {
          console.log("Dataset Station Empty!")
        }
        else
        {
          for(var i = 0; i < dataset_stations.length; i++)
          {

            // Parse OpenWeatherMap API Data to my dataset
            var lat = dataset_stations[i].coord.Lat;
            var lng = dataset_stations[i].coord.Lon;
            var windStation = new google.maps.LatLng(lat, lng);

            var windSpeed = dataset_stations[i].wind.speed;
            var windDeg = dataset_stations[i].wind.deg;

            var windStationEndPoint = findWindEndPoint(windStation, windDeg, windSpeed);

            drawArrowTailToHead(windStation, windStationEndPoint);
          }
        }
      }

      function drawInterpolateWinds() {
        // https://en.wikipedia.org/wiki/Inverse_distance_weighting

        // Use grid points as interpolate points
        var interpolateWinds = grid.slice();

        function weight(i, unknownPoint){
          var powerParameter = 2.0;
          var knownPoint = new google.maps.LatLng(dataset_stations[i].coord.Lat, dataset_stations[i].coord.Lon);
          var distance = Math.pow(google.maps.geometry.spherical.computeDistanceBetween(unknownPoint, knownPoint), powerParameter);

          return parseFloat(1.0/distance);
        }

        function findInterpolateEndPointViaShepardsMethod(pointToInterpolate){
          // returns the end point(head end) of the pointToInterpolate
          // end point(head end) must consider all points in dataset_stations
          // interpolate X-direction & Y-direction

          // X-direction
          var sumNumerator = 0;
          var sumDenom = 0;

          for(var i = 0; i < dataset_stations.length; i++)
          {
            var stationInJSON = dataset_stations[i];
            var stationWindDeg = stationInJSON.wind.deg; // North == 0; East == 90 
            var stationWindSpeed = stationInJSON.wind.speed;

            var x = stationWindSpeed*Math.cos(toRadians(stationWindDeg));

            sumNumerator += weight(i, pointToInterpolate) * x;

            sumDenom += weight(i, pointToInterpolate);
          }
          var dx = parseFloat(sumNumerator/sumDenom);

          // Y-direction
          var sumNumerator = 0;
          var sumDenom = 0;

          for(var i = 0; i < dataset_stations.length; i++)
          {
            var stationInJSON = dataset_stations[i];
            var stationWindDeg = stationInJSON.wind.deg; // North == 0; East == 90 
            var stationWindSpeed = stationInJSON.wind.speed;

            var y = stationWindSpeed*Math.sin(toRadians(stationWindDeg));

            sumNumerator += weight(i, pointToInterpolate) * y;

            sumDenom += weight(i, pointToInterpolate);
          }
          var dy = parseFloat(sumNumerator/sumDenom);

          //dx *= 0.3;
          //dy *= 0.3;


          var newLat = pointToInterpolate.lat() - dx;
          var newLng = pointToInterpolate.lng() - dy;

          if(isNaN(newLat) || isNaN(newLng))
          {
            console("Error: findInterpolateEndPointViaShepardsMethod");
          }
          else
          {
            var newInterpolatedWindPointMag = Math.sqrt((dx*dx)+(dy*dy));
            var newInterpolatedWindPointDeg = Math.atan2(dy,dx);
            newInterpolatedWindPointDeg = newInterpolatedWindPointDeg * 180 / Math.PI;
            // Compute which quad newInterpolatedWindPointDeg is pointing at
            if(0 > newInterpolatedWindPointDeg && newInterpolatedWindPointDeg > -90)
            {
              newInterpolatedWindPointDeg += 360;
            }
            else if(-180 < newInterpolatedWindPointDeg && newInterpolatedWindPointDeg < -90)
            {
              newInterpolatedWindPointDeg += 360;
            }

            var interpolateWindInJSON = {
              "coord":{"Lat":pointToInterpolate.lat(),"Lon":pointToInterpolate.lng()},
              "wind":{"speed":newInterpolatedWindPointMag,"deg":newInterpolatedWindPointDeg} 
            };

            dataset_interpolatedWinds.push(interpolateWindInJSON);

            return new google.maps.LatLng(newLat, newLng);

          }
        }

        // Draw wind for each interpolation point
        for(var i = 0; i < interpolateWinds.length; i++)
        {
          var tail = interpolateWinds[i];
          var head = findInterpolateEndPointViaShepardsMethod(tail);

          var lineSymbol = {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
          };

          var wind_vector = new google.maps.Polyline({
            path: [tail, head],
            icons: [{
              icon: lineSymbol,
              offset: '100%'
            }],
            strokeColor: "#a143ff",
            strokeWeight: "2",
            strokeOpacity: 0.5,
            map: map
          });
        }

      }

      function drawHeatMap() {
        var heatmapData = [];

        for(var i = 0; i < dataset_stations.length; i++)
        {
          // Add station data to heat map
          heatmapData.push({location: new google.maps.LatLng(dataset_stations[i].coord.Lat,dataset_stations[i].coord.Lon), weight: dataset_stations[i].wind.speed});

          // Add interpolated wind data to heat map
          heatmapData.push({location: new google.maps.LatLng(dataset_interpolatedWinds[i].coord.Lat,dataset_interpolatedWinds[i].coord.Lon), weight: dataset_interpolatedWinds[i].wind.speed});
        }

        var heatmap = new google.maps.visualization.HeatmapLayer({
          data: heatmapData,
          radius: 45,
        });
        heatmap.setMap(map);

      }

      function initMap() {

        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 37.13, lng: -119.30},
          zoom: 5
        });

        // Get Grid Coords
        // UL--UR
        // |    |
        // BL--BR

        var UL = new google.maps.LatLng({lat: 42.000, lng: -124.409});
        var UR = new google.maps.LatLng({lat: 42.000, lng: -114.020});
        var BL = new google.maps.LatLng({lat: 32.534, lng: -124.409});
        var BR = new google.maps.LatLng({lat: 32.534, lng: -114.020});
      
        var dx = parseFloat( (UL.lng() - UR.lng()) / 10.0);
        var dy = parseFloat( (UL.lat() - BL.lat()) / 10.0);

        for(var y = 0; y < 11; y++)
        {
          for(var x = 0; x < 11; x++)
          {
            var newLat = parseFloat(UL.lat() - y*dy);
            var newLng = parseFloat(UL.lng() - x*dx);

            var newCoord = new google.maps.LatLng(newLat,newLng);
            grid.push(newCoord);

          }
        }

        // Draw Grid
        for(var i = 0; i < 11; i++)
        {
          // Draw Horizonal Lines
          new google.maps.Polyline({
            path: [ grid[i*11], grid[i*11+10] ],
            map: map,
            strokeColor: "#000000",
            strokeOpacity: 0.3,
            strokeWeight: 2
          });

          // Draw Vertical Lines
          new google.maps.Polyline({
            path: [ grid[i], grid[i+110] ],
            map: map,
            strokeColor: "#000000",
            strokeOpacity: 0.3,
            strokeWeight: 2
          });

        }

        // -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

        //http://api.openweathermap.org/data/2.5/weather?id=5393052&APPID=e2cc8c04d4f4eb4e92d940af42c9e6b6

        //var requestString = "http://api.openweathermap.org/data/2.5/weather?id=5393052" + "&APPID=" + openWeatherMapKey;
        var requestString = "http://api.openweathermap.org/data/2.5/box/city?bbox=" 
        + UL.lng() + "," + UL.lat() + ","
        + BR.lng() +  "," + BR.lat() + ","
        + "7"
        + "&cluster=yes&format=json"
        + "&APPID=" + openWeatherMapKey;
        console.log(requestString);

        // Create a request variable and assign a new XMLHttpRequest object to it.
        var request = new XMLHttpRequest();

        // Open a new connection, using the GET request on the URL endpoint
        request.open("GET", requestString, true);

        request.onload = function(){
          if (this.readyState == 4 && this.status == 200)
          {
            // Begin accessing JSON data here
            var results = JSON.parse(this.responseText);

            //Process Data from OpenWeatherMap API to Google MAPs API
            NUMOFSTATIONS = results.cnt;

            // Parse results from API into my settings (i.e. clone results to my dataset)
            // wind.speed => Unit Default: meter/sec, Metric: meter/sec, Imperial: miles/hour.
            // wind.deg => direction of wind coming FROM ... in degrees (meteorological) => http://snowfence.umn.edu/Components/winddirectionanddegreeswithouttable3.htm
            console.log(results.list); 
            dataset_stations = results.list.slice();

            //drawStations();

            drawStationWinds();

            drawInterpolateWinds();

            drawHeatMap();

          }
          else
          {
            console.error(this.statusText);
          }
        };   
        request.onerror = function(){
          console.error(this.statusText);
        };
        request.send();


      }
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCriTc-URJTbKpAu2HUu4LGL5XEX9cYO8M&libraries=geometry,visualization&callback=initMap"
    async defer></script>
  </body>
  
</html>