<!DOCTYPE html>
<html>

  <head>
    <title>CMPS161 Assignment 1</title>

    <!-- Andrew Pang 1559331 */ -->
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">

    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #floating-panel {
        position: absolute;
        top: 10px;
        left: 25%;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
        text-align: center;
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 10px;
      }
      #floating-panel {
        background-color: #fff;
        border: 1px solid #999;
        left: 25%;
        padding: 5px;
        position: absolute;
        top: 10px;
        z-index: 5;
      }
    </style>

  </head>

  <body>
    <div id="floating-panel">
      <button onclick="toggleHeatmap()">Toggle Heatmap</button>
      <button onclick="toggleStationWind()">Toggle Station Wind</button>
      <button onclick="toggleArrowPlot()">Toggle Arrow Plot</button>
      <button onclick="toggleStreamline()">Toggle Streamline</button>
    </div>

    <div id="map"></div>
    <script>
      var NUMOFSTATIONS = 0;
      var ZOOM = 6;
      var DAMPING = 0.3;


      var map;
      var gridBounds;
      var request;
      var grid = new Array();
      var openWeatherMapKey = "e2cc8c04d4f4eb4e92d940af42c9e6b6";

      var dataset_stations = [];
      var dataset_interpolatedWinds = [];
      var geoJSON = 
      {
        type: "FeatureCollection",
        features: []
      };
      var heatmap;
      var stationWindsLayer = [];
      var interpolatedWindsLayer = [];
      var streamlineLayer = [];

      var stationWindColorRange = ['#0000ff','#6e00e3','#9b00c2','#ba009e','#d50076','#ec0047','#ff0000'];//['#edf8fb', '#b3cde3', '#8c96c6', '#8856a7', '#810f7c'];

      // function scale(num, in_min, in_max, out_min, out_max)
      // {
      //   return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
      // }
      function VelocityMagScale(num)
      {
        var in_min = in_max = dataset_stations[0].wind.speed;//wind speed lowest
        var out_min = 0;
        var out_max = stationWindColorRange.length-1;

        // Find max and min
        for(var i = 0; i < dataset_stations.length; i++)
        {
          var currentSpeed = dataset_stations[i].wind.speed;

          in_min = (currentSpeed < in_min ? currentSpeed : in_min);

          in_max = (currentSpeed > in_max ? currentSpeed : in_max);
        }

        return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
      }

      function toRadians (angle) {
        return angle * (Math.PI / 180);
      }

      function drawStations() {
        // Draw Stations
        if(dataset_stations.length == 0)
        {
          console.log("Dataset Station Empty!")
        }
        for(var i = 0; i < dataset_stations.length; i++)
        {
          var lat = dataset_stations[i].coord.Lat;
          var lng = dataset_stations[i].coord.Lon;
          var station_coord = new google.maps.LatLng(lat, lng);

          new google.maps.Marker({position: station_coord, map: map});
        }
      }

      function findWindEndPoint(sourcePoint, directionInDegrees, mag) {
        // Source Point ===> Interpolated Point
        // Input: LatLng() 
        // Output: LatLng()

        //var stationInJSON = sourcePoint;
        //var stationWindDeg = stationInJSON.wind.deg; // North == 0; East == 90;
        //var stationWindSpeed = stationInJSON.wind.speed;

        // Lat should be X
        // Lng should be Y

        var dx = mag*Math.cos(toRadians(directionInDegrees));
        var dy = mag*Math.sin(toRadians(directionInDegrees));

        // Apply damping so wind arrows aren't so long
        dy *= DAMPING;
        dx *= DAMPING;

        //var tail = new google.maps.LatLng(dataset_stations[i].coord.Lat, dataset_stations[i].coord.Lon);

        var newLat = (sourcePoint.lat() - dx);
        var newLng = (sourcePoint.lng() - dy);

        var head = new google.maps.LatLng(newLat, newLng);

        return head;

      }

      function drawArrowTailToHead(tail, head, color) {
        // Define a symbol using a predefined path (an arrow)
        var lineSymbol = {
          path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
        };

        var arrow = new google.maps.Polyline({
          path: [tail, head],
          icons: [{
            icon: lineSymbol,
            offset: '100%'
          }],
          strokeWeight: "2",
          strokeOpacity: "0.8",
          strokeColor: color,
          map: null
        });

        return arrow;

      }

      function drawStationWinds() {
        // Draw wind vector for each station
        // Check if dataset of stations is empty
        if(dataset_stations.length == 0)
        {
          console.log("Dataset Station Empty!")
        }
        else
        {
          for(var i = 0; i < dataset_stations.length; i++)
          {

            // Parse OpenWeatherMap API Data to my dataset
            var lat = dataset_stations[i].coord.Lat;
            var lng = dataset_stations[i].coord.Lon;
            var windStation = new google.maps.LatLng(lat, lng);

            var windSpeed = dataset_stations[i].wind.speed;
            var windDeg = dataset_stations[i].wind.deg;

            var windStationEndPoint = findWindEndPoint(windStation, windDeg, windSpeed);

            var color = stationWindColorRange[ Math.round(VelocityMagScale(windSpeed)) ];


            stationWindsLayer.push(drawArrowTailToHead(windStation, windStationEndPoint, color));
          }
        }
      }



      function findInterpolateEndPointViaShepardsMethod(pointToInterpolate){
        // pointToInterpolate is a LatLng Class
        // output is JSON
        // returns the end point(head end) of the pointToInterpolate
        // end point(head end) must consider all points in dataset_stations

        function weight(i, unknownPoint){
          var powerParameter = 2.0;
          var knownPoint = new google.maps.LatLng(dataset_stations[i].coord.Lat, dataset_stations[i].coord.Lon);
          var distance = Math.pow(google.maps.geometry.spherical.computeDistanceBetween(unknownPoint, knownPoint), powerParameter);

          return parseFloat(1.0/distance);
        }

        // X-direction & Y-direction
        var sumNumerator_x = 0;
        var sumDenom_x = 0;
        var sumNumerator_y = 0;
        var sumDenom_y = 0;

        for(var i = 0; i < dataset_stations.length; i++)
        {
          var stationInJSON = dataset_stations[i];
          var stationWindDeg = stationInJSON.wind.deg; // North == 0; East == 90 
          var stationWindSpeed = stationInJSON.wind.speed;

          var x = stationWindSpeed*Math.cos(toRadians(stationWindDeg));
          var y = stationWindSpeed*Math.sin(toRadians(stationWindDeg));

          sumNumerator_x += weight(i, pointToInterpolate) * x;
          sumDenom_x += weight(i, pointToInterpolate);

          sumNumerator_y += weight(i, pointToInterpolate) * y;
          sumDenom_y += weight(i, pointToInterpolate);
        }
        var dx = parseFloat(sumNumerator_x/sumDenom_x);
        var dy = parseFloat(sumNumerator_y/sumDenom_y);

        if(isNaN(dx) || isNaN(dy))
        {
          console("Error: findInterpolateEndPointViaShepardsMethod");
        }
        else
        {
          var newInterpolatedWindPointMag = Math.sqrt((dx*dx)+(dy*dy));
          var newInterpolatedWindPointDeg = Math.atan2(dy,dx);
          newInterpolatedWindPointDeg = newInterpolatedWindPointDeg * 180 / Math.PI;
          // Compute which quad newInterpolatedWindPointDeg is pointing at
          if(0 > newInterpolatedWindPointDeg && newInterpolatedWindPointDeg > -90)
          {
            newInterpolatedWindPointDeg += 360;
          }
          else if(-180 < newInterpolatedWindPointDeg && newInterpolatedWindPointDeg < -90)
          {
            newInterpolatedWindPointDeg += 360;
          }

          // Convert data to JSON
          var interpolateWindInJSON = {
            "coord":{"Lat":pointToInterpolate.lat(),"Lon":pointToInterpolate.lng()},
            "wind":{"speed":newInterpolatedWindPointMag,"deg":newInterpolatedWindPointDeg} 
          };


          return interpolateWindInJSON;

        }
      }

      function drawInterpolateWinds() {
        // https://en.wikipedia.org/wiki/Inverse_distance_weighting

        // Use grid points as interpolate points
        var interpolateWinds = grid.slice();


        // Get interpolate wind points, compute, and push into dataset
        for(var i = 0; i < interpolateWinds.length; i++)
        {
          var interpolateWindInJSON = findInterpolateEndPointViaShepardsMethod(interpolateWinds[i]);

          dataset_interpolatedWinds.push(interpolateWindInJSON);
        }

        // Draw wind for each interpolation point
        for(var i = 0; i < dataset_interpolatedWinds.length; i++)
        {
          var lat = dataset_interpolatedWinds[i].coord.Lat;
          var lng = dataset_interpolatedWinds[i].coord.Lon;
          var tail = new google.maps.LatLng(lat, lng);
          //var tail = dataset_interpolatedWinds[i];

          var windSpeed = dataset_interpolatedWinds[i].wind.speed;
          var windDeg = dataset_interpolatedWinds[i].wind.deg;
          var head = findWindEndPoint(tail, windDeg, windSpeed);

          var color = stationWindColorRange[ Math.round(VelocityMagScale(windSpeed)) ];


          var lineSymbol = {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW
          };

          var wind_vector = new google.maps.Polyline({
            path: [tail, head],
            icons: [{
              icon: lineSymbol,
              offset: '100%'
            }],
            strokeColor: "#a143ff",
            strokeWeight: "2",
            strokeOpacity: 0.5,
            strokeColor: color,
            map: null
          });

          interpolatedWindsLayer.push(wind_vector);
        }

      }

      function drawStreamlines() {
        var numOfSteps = 10;
        var streamlineWinds = grid.slice();
        var streamlineCoords = [];


        //var streamlineWinds = grid[0];
        console.log(streamlineWinds);


        // For each interpolate point
        for(var i = 0; i < streamlineWinds.length; i++)
        {
          var ForwardStreamlineCoordsForEachLine = [];
          var BackwardStreamlineCoordsForEachLine = [];
          var basePtInJSON = findInterpolateEndPointViaShepardsMethod(streamlineWinds[i]); //RETURNS IN JSON
          var basePtInLatLng = new google.maps.LatLng(basePtInJSON.coord.Lat, basePtInJSON.coord.Lon); // Convert into LatLng

          var newPtForwardSide = findWindEndPoint(basePtInLatLng, basePtInJSON.wind.deg, basePtInJSON.wind.speed);
          ForwardStreamlineCoordsForEachLine.push(basePtInLatLng);
          //ForwardStreamlineCoordsForEachLine.push(newPtForwardSide);

          var newPtBackwardSide = findWindEndPoint(basePtInLatLng, (basePtInJSON.wind.deg + 180)%360, basePtInJSON.wind.speed);
          BackwardStreamlineCoordsForEachLine.push(basePtInLatLng);
          //BackwardStreamlineCoordsForEachLine.push(newPtBackwardSide);

          // Draw the first arrow i.e. grip point arrows
          streamlineLayer.push(drawArrowTailToHead(basePtInLatLng, newPtForwardSide, "blue"));


          for(var j = 0; j < 200; j++)
          {
            var forwardBasePtInJSON = findInterpolateEndPointViaShepardsMethod(ForwardStreamlineCoordsForEachLine[j]);
            var forwardBasePtInLatLng = new google.maps.LatLng(forwardBasePtInJSON.coord.Lat, forwardBasePtInJSON.coord.Lon);
            var newForwardPt = findWindEndPoint(forwardBasePtInLatLng, forwardBasePtInJSON.wind.deg, forwardBasePtInJSON.wind.speed);
            var forwardColor = stationWindColorRange[ Math.round(VelocityMagScale(forwardBasePtInJSON.wind.speed)) ];


            var backwardBasePtInJSON = findInterpolateEndPointViaShepardsMethod(BackwardStreamlineCoordsForEachLine[j]);
            var backwardBasePtInLatLng = new google.maps.LatLng(backwardBasePtInJSON.coord.Lat, backwardBasePtInJSON.coord.Lon);
            var newBackwardPt = findWindEndPoint(backwardBasePtInLatLng, (backwardBasePtInJSON.wind.deg + 180)%360, backwardBasePtInJSON.wind.speed);
            var backwardColor = stationWindColorRange[ Math.round(VelocityMagScale(backwardBasePtInJSON.wind.speed)) ];



            var ForwardArrow = new google.maps.Polyline({
                path: [forwardBasePtInLatLng, newForwardPt],
                strokeWeight: "2",
                strokeOpacity: "0.5",
                strokeColor: forwardColor,
                map: null
              });

            var BackwardArrow = new google.maps.Polyline({
                path: [backwardBasePtInLatLng, newBackwardPt],
                strokeWeight: "2",
                strokeOpacity: "0.5",
                strokeColor: backwardColor,
                map: null
              });

            if(gridBounds.contains(newForwardPt) && gridBounds.contains(newBackwardPt))
            {
              ForwardStreamlineCoordsForEachLine.push(newForwardPt);
              BackwardStreamlineCoordsForEachLine.push(newBackwardPt);
              //streamlineLayer.push(drawArrowTailToHead(newPtTailSide, newPtHeadSide_check, "red"));
              
              streamlineLayer.push(ForwardArrow);

              streamlineLayer.push(BackwardArrow);

            }
            else if(gridBounds.contains(newForwardPt) && !gridBounds.contains(newBackwardPt))
            {
              // back not inside box so push forward
              ForwardStreamlineCoordsForEachLine.push(newForwardPt);
              BackwardStreamlineCoordsForEachLine.push(backwardBasePtInLatLng);
              streamlineLayer.push(ForwardArrow);
              streamlineLayer.push(BackwardArrow);
            }
            else if(!gridBounds.contains(newForwardPt) && gridBounds.contains(newBackwardPt))
            {
              // back not inside box so push forward
              ForwardStreamlineCoordsForEachLine.push(forwardBasePtInLatLng);
              BackwardStreamlineCoordsForEachLine.push(newBackwardPt);
              streamlineLayer.push(ForwardArrow);
              streamlineLayer.push(BackwardArrow);
            }
            else
            {
              break;
            }
            
          }
        }
        
      }

      function drawHeatMap() {
        var heatmapData = [];

        for(var i = 0; i < dataset_stations.length; i++)
        {
          // Add station data to heat map
          heatmapData.push({location: new google.maps.LatLng(dataset_stations[i].coord.Lat,dataset_stations[i].coord.Lon), weight: dataset_stations[i].wind.speed});

          // Add interpolated wind data to heat map
          heatmapData.push({location: new google.maps.LatLng(dataset_interpolatedWinds[i].coord.Lat,dataset_interpolatedWinds[i].coord.Lon), weight: dataset_interpolatedWinds[i].wind.speed});
        }

        heatmap = new google.maps.visualization.HeatmapLayer({
          data: heatmapData,
          radius: 50,
          dissipating: true
        });
        heatmap.setMap(map);

      }

      function toggleHeatmap() {
        heatmap.setMap(heatmap.getMap() ? null : map);
      }

      function toggleStationWind() {
        clearToggle();
        for(var i = 0; i < stationWindsLayer.length; i++)
        {
          stationWindsLayer[i].setMap(stationWindsLayer[i].getMap() ? null : map);
        }
      }

      function toggleArrowPlot() {
        clearToggle();
        for(var i = 0; i < interpolatedWindsLayer.length; i++)
        {
          interpolatedWindsLayer[i].setMap(interpolatedWindsLayer[i].getMap() ? null : map);
        }
      }

      function toggleStreamline() {
        clearToggle();
        for(var i = 0; i < streamlineLayer.length; i++)
        {
          streamlineLayer[i].setMap(streamlineLayer[i].getMap() ? null : map);
        }
      }

      function clearToggle() {
        for(var i = 0; i < stationWindsLayer.length; i++)
        {
          stationWindsLayer[i].setMap(null);
        }
        for(var i = 0; i < interpolatedWindsLayer.length; i++)
        {
          interpolatedWindsLayer[i].setMap(null);
        }
        for(var i = 0; i < streamlineLayer.length; i++)
        {
          streamlineLayer[i].setMap(null);
        }
      }

      function initMap() {

        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 37.13, lng: -119.30},
          zoom: ZOOM,
          draggable: false

        });

        // Get Grid Coords
        // UL--UR
        // |    |
        // BL--BR

        // var UL = new google.maps.LatLng({lat: 49.01, lng: -125.46});
        // var UR = new google.maps.LatLng({lat: 49.01, lng: -65.91});
        // var BL = new google.maps.LatLng({lat: 24.37, lng: -125.46});
        // var BR = new google.maps.LatLng({lat: 24.37, lng: -65.91});



        var UL = new google.maps.LatLng({lat: 42.000, lng: -124.409});
        var UR = new google.maps.LatLng({lat: 42.000, lng: -114.020});
        var BL = new google.maps.LatLng({lat: 32.534, lng: -124.409});
        var BR = new google.maps.LatLng({lat: 32.534, lng: -114.020});

        gridBounds = new google.maps.LatLngBounds(BL,UR);
      
        var dx = parseFloat( (UL.lng() - UR.lng()) / 10.0);
        var dy = parseFloat( (UL.lat() - BL.lat()) / 10.0);

        for(var y = 0; y < 11; y++)
        {
          for(var x = 0; x < 11; x++)
          {
            var newLat = parseFloat(UL.lat() - y*dy);
            var newLng = parseFloat(UL.lng() - x*dx);

            var newCoord = new google.maps.LatLng(newLat,newLng);
            grid.push(newCoord);

          }
        }

        // Draw Grid
        for(var i = 0; i < 11; i++)
        {
          // Draw Horizonal Lines
          new google.maps.Polyline({
            path: [ grid[i*11], grid[i*11+10] ],
            map: map,
            strokeColor: "#000000",
            strokeOpacity: 0.3,
            strokeWeight: 2
          });

          // Draw Vertical Lines
          new google.maps.Polyline({
            path: [ grid[i], grid[i+110] ],
            map: map,
            strokeColor: "#000000",
            strokeOpacity: 0.3,
            strokeWeight: 2
          });

        }

        // -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_

        //http://api.openweathermap.org/data/2.5/weather?id=5393052&APPID=e2cc8c04d4f4eb4e92d940af42c9e6b6

        //var requestString = "http://api.openweathermap.org/data/2.5/weather?id=5393052" + "&APPID=" + openWeatherMapKey;
        var requestString = "http://api.openweathermap.org/data/2.5/box/city?bbox=" 
        + UL.lng() + "," + UL.lat() + ","
        + BR.lng() +  "," + BR.lat() + ","
        + "7"
        + "&cluster=yes&format=json"
        + "&APPID=" + openWeatherMapKey;
        console.log(requestString);

        // Create a request variable and assign a new XMLHttpRequest object to it.
        var request = new XMLHttpRequest();

        // Open a new connection, using the GET request on the URL endpoint
        request.open("GET", requestString, true);

        request.onload = function(){
          if (this.readyState == 4 && this.status == 200)
          {
            // Begin accessing JSON data here
            var results = JSON.parse(this.responseText);

            //Process Data from OpenWeatherMap API to Google MAPs API
            NUMOFSTATIONS = results.cnt;

            // Parse results from API into my settings (i.e. clone results to my dataset)
            // wind.speed => Unit Default: meter/sec, Metric: meter/sec, Imperial: miles/hour.
            // wind.deg => direction of wind coming FROM ... in degrees (meteorological) => http://snowfence.umn.edu/Components/winddirectionanddegreeswithouttable3.htm
            console.log(results.list); 
            dataset_stations = results.list.slice();

            //drawStations();

            drawStationWinds(); //maybe call loadStationWinds instead

            drawInterpolateWinds(); //this too

            drawHeatMap();

            drawStreamlines();
          }
          else
          {
            console.error(this.statusText);
          }
        };   
        request.onerror = function(){
          console.error(this.statusText);
        };
        request.send();


      }
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCriTc-URJTbKpAu2HUu4LGL5XEX9cYO8M&libraries=geometry,visualization&callback=initMap"
    async defer></script>
  </body>
  
</html>